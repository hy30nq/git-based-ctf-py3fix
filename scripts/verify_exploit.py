#!/usr/bin/env python
###############################################################################
# Git-based CTF
###############################################################################
#
# Author: SeongIl Wi <seongil.wi@kaist.ac.kr>
#         Jaeseung Choi <jschoi17@kaist.ac.kr>
#         Sang Kil Cha <sangkilc@kaist.ac.kr>
#
# Copyright (c) 2018 SoftSec Lab. KAIST
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

import sys
import os
import json
import re
import time
from utils import random_string, docker_cleanup, base_dir, load_config
from utils import prompt_checkout_warning, get_dirname, print_and_log
from cmd import run_command
from git import checkout
from crypto import encrypt_exploit

#-*- coding: utf-8 -*-

# TODO : Get these values via cmdline option
SERVICE_IP = "127.0.0.1"
SERVICE_PORT = 5000

def detect_service_port(service_dir):
    """Dockerfile에서 EXPOSE 또는 ENV PORT를 읽어서 서비스 포트를 감지"""
    dockerfile_path = os.path.join(service_dir, "Dockerfile")
    if not os.path.isfile(dockerfile_path):
        return SERVICE_PORT
    
    with open(dockerfile_path, "r") as f:
        content = f.read()
    
    # EXPOSE 포트 확인
    match = re.search(r'EXPOSE\s+(\d+)', content)
    if match:
        return int(match.group(1))
    
    # ENV 변수에서 포트 확인 (FLASK_RUN_PORT, PORT 등)
    match = re.search(r'(?:FLASK_RUN_PORT|PORT)[=:]\s*(\d+)', content, re.IGNORECASE)
    if match:
        return int(match.group(1))
    
    # ENV 라인에서 포트 확인
    match = re.search(r'ENV\s+(?:FLASK_RUN_PORT|PORT)\s*=\s*(\d+)', content, re.IGNORECASE)
    if match:
        return int(match.group(1))
    
    return SERVICE_PORT

def start_service(service_dir, branch, container_name, flag_str, service_port=None, log=None):
    if service_port is None:
        service_port = SERVICE_PORT

    log= print_and_log("[*] Starting service from %s (branch '%s')" % \
            (service_dir, branch), log)

    # Clean up any existing container with the same name first
    docker_cleanup(container_name)

    checkout(service_dir, branch)

    # Update flag file after checkout to ensure it's not overwritten
    flag_path = os.path.join(service_dir, "flag") # Assumption in template
    if not os.path.isfile(flag_path):
        log = print_and_log("[*] 'flag' file not found in %s" % service_dir, log)
        return False, log
    with open(flag_path, "w") as flag_file:
        flag_file.write(flag_str)

    # Run the service
    script = os.path.join(base_dir(), "setup_service.sh")
    cmdline = \
        "%s %s %d %d" % (script, container_name, service_port, service_port)
    output, err, e = run_command(cmdline, service_dir)
    if e != 0:
        log = print_and_log("[*] Failed to start service", log)
        log = print_and_log(err, log)
        log = print_and_log("==========================", log)
        return False, log
    if log is not None:
        log = log + output

    # Wait for service to be ready
    log = print_and_log("[*] Waiting for service to be ready...", log)
    max_retries = 30
    retry_count = 0
    while retry_count < max_retries:
        _, _, e = run_command('nc -z 127.0.0.1 %d' % service_port, None)
        if e == 0:
            log = print_and_log("[*] Service is ready", log)
            log = print_and_log("[*] Started service successfully", log)
            return True, log
        time.sleep(1)
        retry_count += 1
    
    log = print_and_log("[*] Service failed to start within %d seconds" % max_retries, log)
    return False, log

def run_exploit(exploit_dir, container_name, timeout, service_port=None, log=None):
    if service_port is None:
        service_port = SERVICE_PORT
    
    log = print_and_log("[*] Running exploit", log)

    script = os.path.join(base_dir(), "launch_exploit.sh")
    cmdline = \
      "%s %s %s %d %d" % \
      (script, container_name, SERVICE_IP, service_port, timeout)
    output, err, e = run_command(cmdline, exploit_dir)
    if log is not None:
        log = log + output

    if e != 0:
        log = print_and_log("[*] Failed to run exploit", log)
        log = print_and_log(err, log)
        log = print_and_log("==========================", log)
        return None, log

    # Exploit prints out the flag string at the end.
    # Try to parse JSON first (e.g., {"flag": "..."}), otherwise use last line
    tokens = list(filter(None, output.split('\n'))) # Filter out empty strings
    flag_candidate = None
    if tokens:
        last_line = tokens[-1].strip()
        # Try to parse as JSON
        try:
            json_data = json.loads(last_line)
            if isinstance(json_data, dict) and "flag" in json_data:
                flag_candidate = json_data["flag"]
            else:
                flag_candidate = last_line
        except (json.JSONDecodeError, ValueError):
            # Not JSON, use as-is
            flag_candidate = last_line
    return flag_candidate, log

def verify_exploit(exploit_dir, service_dir, branch, timeout, config,
                   encrypt=False, log=None):
    if not os.path.isdir(exploit_dir) :
        print("[*] Exploit directory '%s' does not exist" % exploit_dir)
        return False, log

    if not os.path.isdir(service_dir) :
        print("[*] Service directory '%s' does not exist" % service_dir)
        return False, log

    # Create random flag value
    flag = random_string(10)

    # Detect service port from Dockerfile
    detected_port = detect_service_port(service_dir)

    # Start the service
    service_dirname = get_dirname(service_dir)
    service_container_name = "%s-%s" % (service_dirname, branch)
    result, log = start_service(service_dir, branch, service_container_name, \
            flag, service_port=detected_port, log=log)
    if not result:
        return False, log

    # Run the exploit
    exploit_dirname = get_dirname(exploit_dir)
    exploit_container_name = "exploit-%s" % branch
    exploit_result, log = run_exploit(exploit_dir, exploit_container_name, \
            timeout, service_port=detected_port, log=log)

    # Clean up containers
    docker_cleanup(service_container_name)
    docker_cleanup(exploit_container_name)

    log = print_and_log("[*] Exploit returned : %s" % exploit_result, log)
    log = print_and_log("[*] Solution flag : %s" % flag, log)
    if exploit_result == flag:
        print("[*] Exploit worked successfully")
        if encrypt:
            print("[*] Encrypting the verified exploit")
            # Set your own team as target team, and signer is not needed.
            target_team = config["player_team"]
            encrypted_file = encrypt_exploit(exploit_dir, target_team, config)
            if encrypted_file is None:
                print("[*] Failed to encrypt exploit")
            else:
                print("[*] Your exploit is encrypted in %s" % encrypted_file)
                print(
                    "[*] Now you may commit and push this encrypted exploit "\
                    "to the corresponding branch of your service repository"
                )
        return True, log
    else:
        log = print_and_log("[*] Exploit returned a wrong flag string", log)
        return False, log

if __name__ == "__main__":
    if len(sys.argv) != 6:
        print(
            "Usage: %s " % sys.argv[0] +
            "[exploit dir] [service dir] [branch] [timeout] [config]"
        )
        sys.exit()

    exploit_dir = sys.argv[1]
    service_dir = sys.argv[2]
    branch = sys.argv[3]
    timeout = int(sys.argv[4])
    config_file = sys.argv[5]
    prompt_checkout_warning(service_dir)
    config = load_config(config_file)
    verify_exploit(exploit_dir, service_dir, branch, timeout, config)
